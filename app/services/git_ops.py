"""
Git Operations Service - WITH PR MANAGEMENT
Includes functions to close existing PRs
"""

import os
from typing import Dict, Any, Optional
from git import Repo
import requests


def create_pull_request(
    github_token: str,
    repo_name: str,
    pr_title: str,
    pr_body: str = None
) -> Dict[str, Any]:
    """
    Create PR from fork dev -> upstream dev

    Args:
        github_token: GitHub personal access token
        repo_name: Repository name in format "org/repo"
        pr_title: Title for the pull request
        pr_body: Optional PR description

    Returns:
        Dictionary with PR details including 'html_url', 'number', etc.

    Raises:
        RuntimeError: If PR creation fails with detailed error message
    """

    fork_owner = os.getenv("GITHUB_USERNAME")
    if not fork_owner:
        raise RuntimeError(
            "âŒ GITHUB_USERNAME not set in environment.\n"
            "Please add your GitHub username to .env file:\n"
            "GITHUB_USERNAME=your_username"
        )

    url = f"https://api.github.com/repos/{repo_name}/pulls"

    headers = {
        "Authorization": f"Bearer {github_token}",
        "Accept": "application/vnd.github+json",
        "X-GitHub-Api-Version": "2022-11-28",
    }

    if pr_body is None:
        pr_body = (
            "## ðŸ¤– Automated Data Platform Intake\n\n"
            "This PR was generated automatically by the MIW Data Platform Intake Bot.\n\n"
            "**Source:** `{fork_owner}:dev` branch\n"
            "**Target:** `{repo_name}:dev` branch\n\n"
            "---\n"
            "*Generated by MIW Data Platform Assistant*"
        ).format(fork_owner=fork_owner, repo_name=repo_name)

    payload = {
        "title": pr_title,
        "head": f"{fork_owner}:dev",
        "base": "dev",
        "body": pr_body,
    }

    try:
        print(f"\nðŸ”„ Creating PR: {pr_title}")
        print(f"   From: {fork_owner}:dev â†’ To: {repo_name}:dev")

        response = requests.post(url, headers=headers, json=payload, timeout=30)

        # SUCCESS - PR created
        if response.status_code == 201:
            pr_data = response.json()
            print(f"âœ… PR created successfully!")
            print(f"   URL: {pr_data['html_url']}")
            print(f"   Number: #{pr_data['number']}")
            return pr_data

        # Handle specific error cases
        error_data = response.json()

        # 422 - Validation error (usually duplicate PR)
        if response.status_code == 422:
            error_message = str(error_data.get('errors', error_data)).lower()

            # Check if it's a duplicate PR error
            if "pull request already exists" in error_message or "already exists" in error_message:
                # Get the existing PR details
                existing_pr = get_existing_pr(github_token, repo_name, fork_owner)

                if existing_pr:
                    # Return the existing PR info in the exception
                    raise RuntimeError(f"PR_EXISTS:{existing_pr['number']}:{existing_pr['html_url']}:{existing_pr['title']}")
                else:
                    raise RuntimeError("PR_EXISTS:unknown")

            # Check if it's a "no commits" error
            elif "no commits" in error_message:
                raise RuntimeError(
                    f"âŒ No commits to create PR.\n\n"
                    f"The branches are already in sync."
                )

            else:
                raise RuntimeError(
                    f"âŒ GitHub validation error:\n{error_data.get('message', 'Unknown error')}"
                )

        # 401 - Authentication error
        elif response.status_code == 401:
            raise RuntimeError("âŒ Authentication failed! Check your GITHUB_TOKEN.")

        # 404 - Repository not found
        elif response.status_code == 404:
            raise RuntimeError(f"âŒ Repository '{repo_name}' not found or no access.")

        # 403 - Forbidden
        elif response.status_code == 403:
            raise RuntimeError("âŒ Permission denied! Check token permissions.")

        # Other errors
        else:
            raise RuntimeError(f"âŒ GitHub API error (status {response.status_code}): {response.text}")

    except requests.exceptions.Timeout:
        raise RuntimeError("âŒ Request timed out!")

    except requests.exceptions.ConnectionError:
        raise RuntimeError("âŒ Connection failed!")

    except requests.exceptions.RequestException as e:
        raise RuntimeError(f"âŒ Network error: {str(e)}")


def get_existing_pr(github_token: str, repo_name: str, fork_owner: str) -> Optional[Dict[str, Any]]:
    """
    Get details of existing PR from fork to upstream

    Returns:
        Dictionary with PR details or None if no PR exists
    """
    try:
        url = f"https://api.github.com/repos/{repo_name}/pulls"
        headers = {
            "Authorization": f"Bearer {github_token}",
            "Accept": "application/vnd.github+json",
        }

        params = {
            "state": "open",
            "head": f"{fork_owner}:dev",
            "base": "dev"
        }

        response = requests.get(url, headers=headers, params=params, timeout=10)

        if response.status_code == 200:
            prs = response.json()
            if prs and len(prs) > 0:
                return {
                    "html_url": prs[0]["html_url"],
                    "title": prs[0]["title"],
                    "number": prs[0]["number"],
                    "state": prs[0]["state"]
                }

        return None

    except Exception as e:
        print(f"Warning: Could not fetch existing PR details: {e}")
        return None


def close_pull_request(
    github_token: str,
    repo_name: str,
    pr_number: int,
    comment: str = None
) -> Dict[str, Any]:
    """
    Close an existing pull request

    Args:
        github_token: GitHub personal access token
        repo_name: Repository name in format "org/repo"
        pr_number: PR number to close
        comment: Optional comment to add before closing

    Returns:
        Dictionary with result status

    Raises:
        RuntimeError: If closing fails
    """
    try:
        headers = {
            "Authorization": f"Bearer {github_token}",
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28",
        }

        # Add comment if provided
        if comment:
            comment_url = f"https://api.github.com/repos/{repo_name}/issues/{pr_number}/comments"
            comment_payload = {"body": comment}

            print(f"ðŸ’¬ Adding comment to PR #{pr_number}")
            comment_response = requests.post(comment_url, headers=headers, json=comment_payload, timeout=30)

            if comment_response.status_code != 201:
                print(f"âš ï¸ Failed to add comment: {comment_response.text}")

        # Close the PR
        close_url = f"https://api.github.com/repos/{repo_name}/pulls/{pr_number}"
        close_payload = {"state": "closed"}

        print(f"ðŸ”’ Closing PR #{pr_number}")
        response = requests.patch(close_url, headers=headers, json=close_payload, timeout=30)

        if response.status_code == 200:
            pr_data = response.json()
            print(f"âœ… PR #{pr_number} closed successfully!")
            return {
                "status": "success",
                "pr_number": pr_number,
                "pr_url": pr_data["html_url"],
                "message": f"PR #{pr_number} has been closed"
            }
        else:
            error_data = response.json()
            raise RuntimeError(f"Failed to close PR: {error_data.get('message', 'Unknown error')}")

    except requests.exceptions.RequestException as e:
        raise RuntimeError(f"âŒ Failed to close PR: {str(e)}")


def check_existing_pr(github_token: str, repo_name: str, fork_owner: str) -> Dict[str, Any]:
    """
    Check if there's an existing open PR from fork dev to upstream dev

    Returns:
        Dictionary with 'exists', 'url', 'title', 'number'
    """
    try:
        existing = get_existing_pr(github_token, repo_name, fork_owner)

        if existing:
            return {
                "exists": True,
                "url": existing["html_url"],
                "title": existing["title"],
                "number": existing["number"]
            }

        return {"exists": False}

    except Exception as e:
        print(f"Error checking existing PR: {e}")
        return {"exists": False}


def add_to_existing_pr(
    github_token: str,
    repo_name: str,
    pr_number: int,
    comment: str = None
) -> Dict[str, Any]:
    """
    Add a comment to existing PR notifying about new changes
    (Changes are already pushed to fork's dev branch, so they auto-appear in PR)

    Args:
        github_token: GitHub personal access token
        repo_name: Repository name in format "org/repo"
        pr_number: PR number to add comment to
        comment: Comment to add

    Returns:
        Dictionary with result
    """
    try:
        if not comment:
            comment = (
                "## ðŸ”„ New Resources Added\n\n"
                "Additional resources have been added to this PR via the MIW Data Platform Assistant.\n\n"
                "Please review the latest commits."
            )

        headers = {
            "Authorization": f"Bearer {github_token}",
            "Accept": "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28",
        }

        comment_url = f"https://api.github.com/repos/{repo_name}/issues/{pr_number}/comments"
        payload = {"body": comment}

        print(f"ðŸ’¬ Adding comment to existing PR #{pr_number}")
        response = requests.post(comment_url, headers=headers, json=payload, timeout=30)

        if response.status_code == 201:
            print(f"âœ… Comment added to PR #{pr_number}")
            return {
                "status": "success",
                "pr_number": pr_number,
                "message": "Comment added to existing PR"
            }
        else:
            error_data = response.json()
            return {
                "status": "warning",
                "message": f"Changes pushed but comment failed: {error_data.get('message', 'Unknown error')}"
            }

    except Exception as e:
        return {
            "status": "warning",
            "message": f"Changes pushed but comment failed: {str(e)}"
        }


def validate_git_config() -> Dict[str, Any]:
    """
    Validate that all required Git/GitHub configuration is present

    Returns:
        Dictionary with validation results
    """
    issues = []

    if not os.getenv("GITHUB_TOKEN1"):
        issues.append("GITHUB_TOKEN1 not set in .env file")

    if not os.getenv("GITHUB_USERNAME"):
        issues.append("GITHUB_USERNAME not set in .env file")

    repo_name = os.getenv("REPO_NAME")
    if not repo_name:
        issues.append("REPO_NAME not set in .env file")
    elif "/" not in repo_name:
        issues.append("REPO_NAME must be in format 'org/repo'")

    return {
        "valid": len(issues) == 0,
        "issues": issues
    }